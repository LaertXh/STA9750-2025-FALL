---
title: "Mini Project 03: Visualizing and Maintaining the Green Canopy of NYC"
author: "Laert Xhumari"
format: 
  html:
    code-fold: true
    code-tools: true
execute:
  warning: false
  message: false
  echo: true
  results: hide
---

New York has a very dense diverse tree population. Trees are not limited to just the parts, as expected they are everywhere within the side walks. I have wittnessed storms take down trees, and those trees will get replaced with a new one very quickly. In this analysis we awill limit the amount of data that we evaluate due to computing issues, so please keep in mind the this is not the full picture of the tree population, but an excellent brief overview at it. 

## Data Gathering and Cleaning

```{r}
#| code-summary: "CODE: Libraries"
#| message: false
#| warning: false

library(sf)
library(tidyverse)
library(httr2)
```

```{r}
#| code-summary: "CODE: Task 1"
#| message: false

download_city_council <- function() {
  dir_path <- "data/mp03"
  zip_path <- file.path(dir_path, "nycc_25.zip")
  url <- "https://s-media.nyc.gov/agencies/dcp/assets/files/zip/data-tools/bytes/city-council/nycc_25c.zip"

  #create directory if needed
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }

  #download ZIP if missing
  if (!file.exists(zip_path)) {
    message("Downloading NYC City Council district boundaries...")
    download.file(url, destfile = zip_path, mode = "wb")
  }

  #unzip only if not already done
  unzip_dir <- file.path(dir_path, "nycc_25")
  if (!dir.exists(unzip_dir)) {
    unzip(zip_path, exdir = unzip_dir)
  }

  #recursively find the shapefile (this solves your problem)
  shp_file <- list.files(unzip_dir, pattern = "\\.shp$", recursive = TRUE, full.names = TRUE)[1]

  if (is.na(shp_file)) {
    stop("ERROR: No .shp file found in extracted ZIP directory.")
  }

  #read + transform
  council_sf <- sf::st_read(shp_file, quiet = TRUE)
  council_sf <- sf::st_transform(council_sf, crs = "WGS84")

  return(council_sf)
}
council <- download_city_council()
```

```{r}
#| code-summary: "CODE: Task 2"
#| message: false

download_tree_points <- function(
    base_url = "https://data.cityofnewyork.us/resource/hn5i-inap.geojson",
    output_dir = "data/mp03",
    limit = 10000,
    max_retries = 3,
    sleep_time = 0.4
) {

  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  page <- 0
  file_list <- c()

  repeat {
    offset <- page * limit
    file_path <- file.path(output_dir, sprintf("trees_page_%04d.geojson", page))

    if (!file.exists(file_path)) {

      message(sprintf("Downloading page %d (offset %d)...", page, offset))

      success <- FALSE

      for (attempt in 1:max_retries) {

        req <- request(base_url) |>
          req_url_query(`$limit` = limit, `$offset` = offset) |>
          req_timeout(300) |>
          req_error(is_error = function(resp) FALSE)

        resp <- try(req_perform(req), silent = TRUE)

        if (!inherits(resp, "try-error") &&
            resp_status(resp) == 200 &&
            length(resp_body_raw(resp)) > 0) {

          writeBin(resp_body_raw(resp), file_path)
          success <- TRUE
          break

        } else {
          message(sprintf(
            "  Attempt %d failed. Retrying in 5 seconds...",
            attempt
          ))
          Sys.sleep(5)
        }
      }

      if (!success) {
        stop(sprintf("Failed to download page %d after retries.", page))
      }

      Sys.sleep(sleep_time)
    }

    # Socrata returns empty pages with "{}" or "[]"
    raw_txt <- readLines(file_path, warn = FALSE)
    if (length(raw_txt) == 0) {
      message("Reached end of data (empty file).")
      break
    }

    # Check for empty feature collection
    if (grepl('"features" *: *\\[ *\\]', raw_txt)) {
      message("Reached end of data (no features).")
      break
    }

    # Now safe to read JSON as sf
    sf_page <- try(sf::st_read(file_path, quiet = TRUE), silent = TRUE)

    if (inherits(sf_page, "try-error") || nrow(sf_page) == 0) {
      message("Reached end of data.")
      break
    }

    file_list <- c(file_list, file_path)
    page <- page + 1
  }

  # Combine all downloaded pages
  if (length(file_list) == 0) {
    stop("No tree data downloaded.")
  }

  message("Combining all pages...")
  sf_list <- lapply(file_list, function(f) {
    x <- sf::st_read(f, quiet = TRUE)

    # FIX: Normalize any date/datetime fields to character
    x <- x %>%
      mutate(across(
        where(~ inherits(., "POSIXct") || inherits(., "POSIXt") || inherits(., "Date")),
        as.character
      ))

    return(x)
  })

  trees <- dplyr::bind_rows(sf_list)


  message(sprintf("Total rows downloaded: %d", nrow(trees)))

  return(trees)
}


ny_trees <- download_tree_points(limit = 10000)
```

## Map Overview
```{r}
#| code-summary: "CODE: Task 3 — Plot all tree points over council districts"
#| message: false

library(dplyr)
library(ggplot2)
library(sf)

ggplot() +
  geom_sf(
    data = council,
    fill = "grey95",
    color = "white",
    linewidth = 0.2
  ) +
  geom_sf(
    data = ny_trees,
    aes(),
    color = "darkgreen",
    alpha = 0.05,
    size = 0.2
  ) +
  coord_sf() +
  theme_minimal() +
  labs(
    title = "NYC Trees Mapped Over City Council Districts",
    subtitle = "1.1 million tree points shown on top of 51 council district boundaries",
    caption = "Data: NYC Parks TreeMap & NYC City Council Districts"
  )

```

This map now shows a great overview of the tree distribution within New York. Please note that this is not showing very tree that is avaliable, we have limited the results to pull only 10,000 trees from each page avaliable for computational reasons. 

## District-Level Analyses of Trees

```{r}
#| code-summary: "CODE: Task 4 — Spatial join"
#| message: false

library(dplyr)
library(sf)

# Spatial join: assign each tree to its council district
trees_joined <- st_join(
  council,
  ny_trees,
  join = st_contains
)
```

```{r}
#| code-summary: "CODE: Task 4.1 — Which council district has the most trees?"
#| message: false

most_trees <- trees_joined |>
  count(CounDist, name = "tree_count") |>
  arrange(desc(tree_count)) |>
  slice(1)
```

The district with the most trees is District `r most_trees$CounDist` with `r most_trees$tree_count` trees.

```{r}
#| code-summary: "CODE: Task 4.2 — Highest Density."
#| message: false

tree_density <- trees_joined |>
  count(CounDist, Shape_Area, name = "tree_count") |>
  mutate(tree_density = tree_count / Shape_Area)

highest_density <- tree_density |>
  arrange(desc(tree_density)) |>
  slice(1)
```

The district with the highest tree density is District `r highest_density$CounDist` with a density of `r signif(highest_density$tree_density, 4)` trees per map unit.

```{r}
#| code-summary: "CODE: Task 4.3 — Highest Fraction of Dead Trees"
#| message: false

dead_fraction <- trees_joined |>
  group_by(CounDist) |>
  summarize(
    total_trees = n(),
    dead_trees = sum(tpcondition == "Dead", na.rm = TRUE),
    dead_frac = dead_trees / total_trees
  )

highest_dead_fraction <- dead_fraction |>
  arrange(desc(dead_frac)) |>
  slice(1)

```

The district with the highest dead-tree fraction is District `r highest_dead_fraction$CounDist` with `r scales::percent(highest_dead_fraction$dead_frac, accuracy = 0.1)` dead trees.

```{r}
#| code-summary: "CODE: Task 4.4 — Tree Species"
#| message: false

trees_joined_boro <- trees_joined |>
  mutate(
    Borough = case_when(
      CounDist >= 1  & CounDist <= 10 ~ "Manhattan",
      CounDist >= 11 & CounDist <= 18 ~ "Bronx",
      CounDist >= 19 & CounDist <= 32 ~ "Queens",
      CounDist >= 33 & CounDist <= 48 ~ "Brooklyn",
      CounDist >= 49 & CounDist <= 51 ~ "Staten Island"
    )
  )

most_common_species_manhattan <- trees_joined_boro |>
  filter(Borough == "Manhattan") |>
  count(genusspecies, sort = TRUE) |>
  slice(1)

```

The most common tree species in Manhattan is `r most_common_species_manhattan$genusspecies`.

```{r}
#| code-summary: "CODE: Task 4.5 — Species of Tree Closest to Baruch."
#| message: false

new_st_point <- function(lat, lon, ...){
  st_sfc(st_point(c(lon, lat))) |> 
    st_set_crs("WGS84")
}

baruch_point <- new_st_point(40.7403, -73.9832)

trees_with_dist <- ny_trees |>
  mutate(distance = st_distance(geometry, baruch_point))

nearest_tree <- trees_with_dist |>
  slice_min(distance, n = 1) |>
  select(genusspecies, distance)

```

The nearest tree to Baruch College is a `r nearest_tree$genusspecies`, located approximately `r round(as.numeric(nearest_tree$distance), 1)` meters away.